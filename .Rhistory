setnames(file,c(f.voc,f.code),c("Type2","Code2"))
#Create variable code_no_dot by removing dot from all codes
codesheet[,code_no_dot := gsub("\\.","",codesheet[,Code])]
file[,code_no_dot2 := gsub("\\.","",file[,Code2])]
#codesheet[,dot_present := str_detect(codesheet[,Code],"\\.")]
#Merge codesheet to data file using sql. Then it is possible to merge on start_with or exact in 1 step
if(method == "SQL"){
codesheet[,start_with := fifelse(substr(Code,nchar(Code),nchar(Code) + 1) == "." | Type %in% c.startwith ,"T","F")]
TEMP1 <- sqldf("
select distinct t1.*, t2.Concept
from file t1
inner join codesheet t2
on (
t1.Type2 = t2.Type
and
(
(
t2.start_with = 'T'
and
substr(t1.code_no_dot2,1,length(t2.code_no_dot)) = substr(t2.code_no_dot,1,length(t2.code_no_dot))
)
or
(
t2.start_with = 'F'
and
t1.code_no_dot2 = t2.code_no_dot
)
)
)
")
TEMP1 <- as.data.table(TEMP1)
TEMP1 <- TEMP[, Concept := names(conditions1)[[i]]]
#TEMP[,start_with := NULL]
setorder(TEMP1, person_id, Concept,Type2, start_date_record,Code2, code_no_dot2)
setnames(TEMP1,c("Type2","Code2","code_no_dot2","Concept"),c(f.voc,f.code,paste0(f.code,"_2"),c.concept))
for(i in unique(codesheet[["Concept"]])){
TEMP2 <- TEMP1[get(c.concept) == i,]
saveRDS(object = TEMP2, file = paste0(path,"/",i,".rds"))
rm(TEMP2)
gc()
}
rm(TEMP1)
gc()
}
if(method == "loop"){
#Create variable to distinct codes that need to be extracted based on start with and not exact.
codesheet[,start_with := fifelse(substr(Code,nchar(Code),nchar(Code) + 1) == "." | Type %in% c.startwith ,T,F)]
# Create list for the for loop
#First 1 list with codes for exact matching
conditions1<-vector(mode="list", length=length(unique(na.omit(codesheet[["Concept"]]))))
names(conditions1)<-unique(na.omit(codesheet[["Concept"]]))
for (i in 1:length(conditions1)){
vocabularies<-vector(mode="list", length=length(systems_analysed))
names(vocabularies)<-systems_analysed
for (j in 1:length(vocabularies)){
vocabularies[[j]]$exact <- codesheet[Concept == names(conditions1)[i] & Type == names(vocabularies)[j] & start_with == F, code_no_dot]
vocabularies[[j]]$start <- codesheet[Concept == names(conditions1)[i] & Type == names(vocabularies)[j] & start_with == T, code_no_dot]
}
conditions1[[i]]<-list.append(conditions1[[i]],vocabularies)
rm(vocabularies)
}
#remove empty vocabularies
conditions1<-lapply(conditions1, function(x) Filter(length, x))
#Write codes to disk per concepts
for(i in 1:length(names(conditions1))){
TEMP <- file[0]
for(j in 1:length(names(conditions1[[j]]))){
TEMP2 <- copy(file)
TEMP2 <- unique(TEMP2[
Type2 == names(conditions1[[i]][j])
&
(
length(conditions1[[i]][[j]]$start) > 0 & grepl(pattern =  paste0("^",conditions1[[i]][[j]]$start,collapse ="|"), x = code_no_dot2)
|
length(conditions1[[i]][[j]]$exact) > 0 & code_no_dot2 %in% conditions1[[i]][[j]]$exact
)
,])
TEMP <- rbindlist(list(TEMP,TEMP2),fill = T, use.names = T)
rm(TEMP2)
}
TEMP <- TEMP[, Concept := names(conditions1)[[i]]]
#TEMP[,start_with := NULL]
setorder(TEMP, person_id, Concept,Type2, start_date_record,Code2, code_no_dot2)
setnames(TEMP,c("Type2","Code2","code_no_dot2","Concept"),c(f.voc,f.code,paste0(f.code,"_2"),c.concept))
saveRDS(object = TEMP, file = paste0(path,"/",names(conditions1)[[i]],".rds"))
rm(TEMP)
gc()
}
}
}
peakRAM(CreateConceptDatasets(
codesheet = FILE,
c.voc = "Coding_system",
c.concept = "sheet",
c.codes = "Code",
file = Events,
f.code = "event_code",
f.voc =  "event_record_vocabulary",
c.startwith = c("ICD10/CM","ICD9CM","ICD9"),
path = "C:/TESTSQL",
method = "SQL"
))
#' This is my first package
#'
#'
#' @section ??
#'
#' @author
#' Roel Elbers
#'
#' @docType package
#' @name PrepCDM
#' @keywords ??
#' @import data.table
NULL
#' @param codesheet data.table file with the codes, concept and coding system
#' @param file CDM table with codes
#' @param c.voc codesheet coding system column name
#' @param c.concept codesheet concept column name
#' @param c.codes codesheet code column name
#' @param coding systems that merges based on start with
#' @param f.code file code column name
#' @param f.voc file coding system column name
#' @param path location to write the RDS files to per concept name
#' @param method if SQL, a join is used. If loop a loop is used to subset
#' @result RDS files to per concept name with the rows that have the code specified in the codesheet
#' @export
CreateConceptDatasets <- function(codesheet,file, c.voc, c.concept,c.codes,c.startwith,f.code,f.voc,path,method = "SQL" ){
#Get data. If not use copy input dataset may be affected (see data.table properties)
codesheet <- copy(codesheet)
file <- copy(file)
#Check if vocabulary matches the feeded codesheet coding system.
systems_data <- unique(na.omit(file[[f.voc]]))
systems_codesheet <- unique(na.omit(codesheet[[c.voc]]))
systems_analysed <- systems_data[systems_data %in% systems_codesheet]
systems_nanalysed <- systems_data[!systems_data %in% systems_codesheet]
if(length(systems_nanalysed) > 0) print(paste0(systems_nanalysed," is not in codesheet so these rows are lost."))
#check if specified c.startwith is in codesheet
if(sum(!c.startwith %in% systems_codesheet > 0)) print("check c.startwith, misspelling occured resulting in missing codes")
#Standardize columns names. This to prevent the use of the get, eval statements which complicate code readability and give sometimes complex errors
setnames(codesheet,c(c.voc,c.concept,c.codes),c("Type","Concept","Code"))
setnames(file,c(f.voc,f.code),c("Type2","Code2"))
#Create variable code_no_dot by removing dot from all codes
codesheet[,code_no_dot := gsub("\\.","",codesheet[,Code])]
file[,code_no_dot2 := gsub("\\.","",file[,Code2])]
#codesheet[,dot_present := str_detect(codesheet[,Code],"\\.")]
#Merge codesheet to data file using sql. Then it is possible to merge on start_with or exact in 1 step
if(method == "SQL"){
codesheet[,start_with := fifelse(substr(Code,nchar(Code),nchar(Code) + 1) == "." | Type %in% c.startwith ,"T","F")]
TEMP1 <- sqldf("
select distinct t1.*, t2.Concept
from file t1
inner join codesheet t2
on (
t1.Type2 = t2.Type
and
(
(
t2.start_with = 'T'
and
substr(t1.code_no_dot2,1,length(t2.code_no_dot)) = substr(t2.code_no_dot,1,length(t2.code_no_dot))
)
or
(
t2.start_with = 'F'
and
t1.code_no_dot2 = t2.code_no_dot
)
)
)
")
TEMP1 <- as.data.table(TEMP1)
#TEMP1[,start_with := NULL]
setorder(TEMP1, person_id, Concept,Type2, start_date_record,Code2, code_no_dot2)
setnames(TEMP1,c("Type2","Code2","code_no_dot2","Concept"),c(f.voc,f.code,paste0(f.code,"_2"),c.concept))
for(i in unique(codesheet[["Concept"]])){
TEMP2 <- TEMP1[get(c.concept) == i,]
saveRDS(object = TEMP2, file = paste0(path,"/",i,".rds"))
rm(TEMP2)
gc()
}
rm(TEMP1)
gc()
}
if(method == "loop"){
#Create variable to distinct codes that need to be extracted based on start with and not exact.
codesheet[,start_with := fifelse(substr(Code,nchar(Code),nchar(Code) + 1) == "." | Type %in% c.startwith ,T,F)]
# Create list for the for loop
#First 1 list with codes for exact matching
conditions1<-vector(mode="list", length=length(unique(na.omit(codesheet[["Concept"]]))))
names(conditions1)<-unique(na.omit(codesheet[["Concept"]]))
for (i in 1:length(conditions1)){
vocabularies<-vector(mode="list", length=length(systems_analysed))
names(vocabularies)<-systems_analysed
for (j in 1:length(vocabularies)){
vocabularies[[j]]$exact <- codesheet[Concept == names(conditions1)[i] & Type == names(vocabularies)[j] & start_with == F, code_no_dot]
vocabularies[[j]]$start <- codesheet[Concept == names(conditions1)[i] & Type == names(vocabularies)[j] & start_with == T, code_no_dot]
}
conditions1[[i]]<-list.append(conditions1[[i]],vocabularies)
rm(vocabularies)
}
#remove empty vocabularies
conditions1<-lapply(conditions1, function(x) Filter(length, x))
#Write codes to disk per concepts
for(i in 1:length(names(conditions1))){
TEMP <- file[0]
for(j in 1:length(names(conditions1[[j]]))){
TEMP2 <- copy(file)
TEMP2 <- unique(TEMP2[
Type2 == names(conditions1[[i]][j])
&
(
length(conditions1[[i]][[j]]$start) > 0 & grepl(pattern =  paste0("^",conditions1[[i]][[j]]$start,collapse ="|"), x = code_no_dot2)
|
length(conditions1[[i]][[j]]$exact) > 0 & code_no_dot2 %in% conditions1[[i]][[j]]$exact
)
,])
TEMP <- rbindlist(list(TEMP,TEMP2),fill = T, use.names = T)
rm(TEMP2)
}
TEMP <- TEMP[, Concept := names(conditions1)[[i]]]
#TEMP[,start_with := NULL]
setorder(TEMP, person_id, Concept,Type2, start_date_record,Code2, code_no_dot2)
setnames(TEMP,c("Type2","Code2","code_no_dot2","Concept"),c(f.voc,f.code,paste0(f.code,"_2"),c.concept))
saveRDS(object = TEMP, file = paste0(path,"/",names(conditions1)[[i]],".rds"))
rm(TEMP)
gc()
}
}
}
peakRAM(CreateConceptDatasets(
codesheet = FILE,
c.voc = "Coding_system",
c.concept = "sheet",
c.codes = "Code",
file = Events,
f.code = "event_code",
f.voc =  "event_record_vocabulary",
c.startwith = c("ICD10/CM","ICD9CM","ICD9"),
path = "C:/TESTSQL",
method = "SQL"
))
peakRAM(CreateConceptDatasets(
codesheet = FILE,
c.voc = "Coding_system",
c.concept = "sheet",
c.codes = "Code",
file = Events,
f.code = "event_code",
f.voc =  "event_record_vocabulary",
c.startwith = c("ICD10/CM","ICD9CM","ICD9"),
path = "C:/TESTLOOP",
method = "loop"
))
for(i in unique(codesheet[["Concept"]])){
LOOP <- readRDS(paste0("C:/TESTLOOP/",i,".rds"))[,.(person_id, Concept,Type2, start_date_record,Code2, code_no_dot2)]
setorder(LOOP, person_id, Concept,Type2, start_date_record,Code2, code_no_dot2)
SQL <- readRDS(paste0("C:/TESTSQL/",i,".rds"))[,.(person_id, Concept,Type2, start_date_record,Code2, code_no_dot2)]
setorder(SQL, person_id,Concept,Type2,start_date_record,Code2, code_no_dot2)
check <- T
if(sum((nrow(SQL) == nrow(LOOP)) == F) > 0){
print(paste0(i," has unequal number of rows"))
check <- F
}
if(sum((ncol(SQL) == ncol(LOOP)) == F) > 0){
print(paste0(i," has unequal number of columns"))
check <- F
}
if(sum((colnames(SQL) == colnames(LOOP)) == F) > 0){
print(paste0(i," has unequal colnames"))
check <- F
}
if(check){
test <- LOOP == SQL
if(sum(test == F) > 0) print(i) else print(paste0(i," correct"))
rm(test)
}
rm(SQL,LOOP)
gc()
}
for(i in unique(codesheet[["Concept"]])){
LOOP <- readRDS(paste0("C:/TESTLOOP/",i,".rds"))[,.(person_id, Concept,Type2, start_date_record,Code2, code_no_dot2)]
#setorder(LOOP, person_id, Concept,Type2, start_date_record,Code2, code_no_dot2)
SQL <- readRDS(paste0("C:/TESTSQL/",i,".rds"))[,.(person_id, Concept,Type2, start_date_record,Code2, code_no_dot2)]
#setorder(SQL, person_id,Concept,Type2,start_date_record,Code2, code_no_dot2)
check <- T
if(sum((nrow(SQL) == nrow(LOOP)) == F) > 0){
print(paste0(i," has unequal number of rows"))
check <- F
}
if(sum((ncol(SQL) == ncol(LOOP)) == F) > 0){
print(paste0(i," has unequal number of columns"))
check <- F
}
if(sum((colnames(SQL) == colnames(LOOP)) == F) > 0){
print(paste0(i," has unequal colnames"))
check <- F
}
if(check){
test <- LOOP == SQL
if(sum(test == F) > 0) print(i) else print(paste0(i," correct"))
rm(test)
}
rm(SQL,LOOP)
gc()
}
for(i in unique(codesheet[["Concept"]])){
LOOP <- readRDS(paste0("C:/TESTLOOP/",i,".rds"))[,.(person_id, sheet,event_record_vocabulary, start_date_record,event_code, event_code_2)]
#setorder(LOOP, person_id, Concept,Type2, start_date_record,Code2, code_no_dot2)
SQL <- readRDS(paste0("C:/TESTSQL/",i,".rds"))[,.(person_id, sheet,event_record_vocabulary, start_date_record,event_code, event_code_2)]
#setorder(SQL, person_id,Concept,Type2,start_date_record,Code2, code_no_dot2)
check <- T
if(sum((nrow(SQL) == nrow(LOOP)) == F) > 0){
print(paste0(i," has unequal number of rows"))
check <- F
}
if(sum((ncol(SQL) == ncol(LOOP)) == F) > 0){
print(paste0(i," has unequal number of columns"))
check <- F
}
if(sum((colnames(SQL) == colnames(LOOP)) == F) > 0){
print(paste0(i," has unequal colnames"))
check <- F
}
if(check){
test <- LOOP == SQL
if(sum(test == F) > 0) print(i) else print(paste0(i," correct"))
rm(test)
}
rm(SQL,LOOP)
gc()
}
rm(list = ls(all=TRUE))
if(!require(rstudioapi)){install.packages("rstudioapi")}
library(rstudioapi)
if(!require(devtools)){install.packages("devtools")}
library(devtools)
if(!require(knitr)){install.packages("knitr")}
library(knitr)
devtools::install_github("klutometis/roxygen")
usethis::use_roxygen_md("C:/PrepCDM")
setwd("C:/PrepCDM")
usethis::use_roxygen_md()
install.packages("PrepCDM")
library("PrepCDM")
??CreateConceptDatasets
?CreateConceptDatasets()
??CreateConceptDatasets()
library(PrepCDM)
install.packages("PrepCDM")
install.packages("PrepCDM")
library("PrepCDM")
??CreateConceptDatasets
library("PrepCDM")
help(CreateConceptDatasets)
setwd("C:/PrepCDM")
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
help(CreateConceptDatasets)
usethis::use_test("CreateConceptDatasets")
library(PrepCDM)
FILE <- fread(paste0(pre_dir,"Events.csv"))[,.(Coding_system,Code,sheet)]
library(data.table)
FILE <- fread(paste0(pre_dir,"Events.csv"))[,.(Coding_system,Code,sheet)]
#Author:Roel Elbers MSc.
#email: r.j.h.elbers@umcutrecht.nl
#Organisation: UMC Utrecht, Utrecht, The Netherlands
#Date: 26/07/2021
rm(list=ls())
if(!require(rstudioapi)){install.packages("rstudioapi")}
library(rstudioapi)
projectFolder<-dirname(rstudioapi::getSourceEditorContext()$path)
#setwd(projectFolder)
StudyName <- "Pfizer"
###################################################
#Parameters
#################################################
#females age
min_age_preg<-12
max_age_preg<-55
#Set parameters basic parameters
#Start Defined as launch of the vaccin in relavant country (SAP) (Date creation?)
start_study_date <- "19950101"
#Date of last vaccinated subject according to SAP, then check CDM_Source if recommend end date is earlier
end_study_date <- "20221231"
lookback_period <- 365
max_spells_gap <- 20
Age_min <- 0
Age_max <- 56 ##??
######################################################################################################
#Specify all meanings that refer to birth registry in the SURVEY_ID table(if applicable) for identifying pregnancy
#example meanings_birth_registry<-c("birth_registry", "birth_registry_meanings")
#keep in mind this records will be classified as end_of_pregnancy so no spontaneous abortion registry should be included
#meanings_birth_registry<-c("birth_registry_mother")
#######################################################################################################
source(paste0(projectFolder,"/packages.R"))
source(paste0(projectFolder,"/99_path.R"))
source(paste0(pre_dir,"functions/", "FUNCTIONS.R"))
FILE <- fread(paste0(pre_dir,"Events.csv"))[,.(Coding_system,Code,sheet)]
Events <- IMPORT_PATTERN(dir = path_dir, pat = "EVENTS")
saveRDS(Events,"C:/PrepCDM/tests/testthat/Events.rds")
FILE <- fread("Events.csv")[,.(Coding_system,Code,sheet)]
setwd("C:/PrepCDM/tests/testthat")
FILE <- fread("Events.csv")[,.(Coding_system,Code,sheet)]
expect_equal(nrow(FILE), 14392)
Events <- readRDS("Events.rds")
CreateConceptDatasets(
codesheet = FILE,
c.voc = "Coding_system",
c.concept = "sheet",
c.codes = "Code",
file = Events,
f.code = "event_code",
f.voc =  "event_record_vocabulary",
c.startwith = c("ICD10/CM","ICD9CM","ICD9"),
path = "Output",
method = "SQL"
)
for(i in unique(FILE[["sheet"]])){
OUTPUT <- readRDS(paste0("Output/",i,".rds"))[,.(person_id, sheet,event_record_vocabulary, start_date_record,event_code, event_code_2)]
TEST <- readRDS(paste0("Test/",i,".rds"))[,.(person_id, sheet,event_record_vocabulary, start_date_record,event_code, event_code_2)]
print(sum((OUTPUT == TEST) == F))
}
library(PrepCDM)
FILE <- fread(paste0(pre_dir,"Events.csv"))[,.(Coding_system,Code,sheet)]
Events <- IMPORT_PATTERN(dir = path_dir, pat = "EVENTS")
peakRAM(CreateConceptDatasets(
codesheet = FILE,
c.voc = "Coding_system",
c.concept = "sheet",
c.codes = "Code",
file = Events,
f.code = "event_code",
f.voc =  "event_record_vocabulary",
c.startwith = c("ICD10/CM","ICD9CM","ICD9"),
path = concepts_dir,
method = "SQL"
))
CreateConceptDatasets(
codesheet = FILE,
c.voc = "Coding_system",
c.concept = "sheet",
c.codes = "Code",
file = Events,
f.code = "event_code",
f.voc =  "event_record_vocabulary",
c.startwith = c("ICD10/CM","ICD9CM","ICD9"),
path = concepts_dir,
method = "SQL"
)
library(PrepCDM)
CreateConceptDatasets(
codesheet = FILE,
c.voc = "Coding_system",
c.concept = "sheet",
c.codes = "Code",
file = Events,
f.code = "event_code",
f.voc =  "event_record_vocabulary",
c.startwith = c("ICD10/CM","ICD9CM","ICD9"),
path = concepts_dir,
method = "SQL"
)
if(!require(devtools)){install.packages("devtools")}
library(devtools)
detach("package:PrepCDM", unload = TRUE)
devtools::install_github("relbersumcu/PrepCDM")
library("PrepCDM")
CreateConceptDatasets(
codesheet = FILE,
c.voc = "Coding_system",
c.concept = "sheet",
c.codes = "Code",
file = Events,
f.code = "event_code",
f.voc =  "event_record_vocabulary",
c.startwith = c("ICD10/CM","ICD9CM","ICD9"),
path = concepts_dir,
method = "SQL"
)
setwd("C:/PrepCDM")
library(PrepCDM)
setwd("C:/PrepCDM")
devtools::install()
library(PrepCDM)
FILE <- fread(paste0(pre_dir,"Events.csv"))[,.(Coding_system,Code,sheet)]
Events <- IMPORT_PATTERN(dir = path_dir, pat = "EVENTS")
if(!require(devtools)){install.packages("devtools")}
library(devtools)
detach("package:PrepCDM", unload = TRUE)
devtools::install_github("relbersumcu/PrepCDM")
if(!require(devtools)){install.packages("devtools")}
library(devtools)
detach("package:PrepCDM", unload = TRUE)
devtools::install_github("relbersumcu/PrepCDM")
library("PrepCDM")
CreateConceptDatasets(
codesheet = FILE,
c.voc = "Coding_system",
c.concept = "sheet",
c.codes = "Code",
file = Events,
f.code = "event_code",
f.voc =  "event_record_vocabulary",
c.startwith = c("ICD10/CM","ICD9CM","ICD9"),
path = concepts_dir,
method = "SQL"
)
library(PrepCDM)
library(PrepCDM)
